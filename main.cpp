#include "adeba.h"
#include "xor.h"

#define STR Decrypt({ 0x7, 0x28, 0x26, 0x69, 0x39, 0x26, 0x2d, 0x2c, 0x69, 0x2a, 0x26, 0x27, 0x2f, 0x20, 0x3b, 0x24, 0x28, 0x3b, 0x69, 0x28, 0x69, 0x28, 0x3b, 0x38, 0x3c, 0x20, 0x3d, 0x2c, 0x3d, 0x3c, 0x3b, 0x28, 0x69, 0x28, 0x25, 0x3f, 0x26, 0x73, 0x69, 0x79, 0x31, 0x6c, 0x11, 0x43 }).c_str()
#define STR2 Decrypt({ 0x7, 0x3c, 0x24, 0x2c, 0x3b, 0x26, 0x69, 0x2d, 0x2c, 0x69, 0x28, 0x3b, 0x2e, 0x3c, 0x24, 0x2c, 0x27, 0x3d, 0x26, 0x3a, 0x69, 0x20, 0x27, 0x3f, 0x28, 0x25, 0x20, 0x2d, 0x26, 0x43 }).c_str()
#define STR3 Decrypt({ 0xf, 0x28, 0x25, 0x21, 0x26, 0x3c, 0x69, 0x26, 0x69, 0x3a, 0x27, 0x28, 0x39, 0x73, 0x69, 0x79, 0x31, 0x6c, 0x11, 0x43 }).c_str()
#define STR4 Decrypt({ 0xf, 0x28, 0x25, 0x21, 0x28, 0x69, 0x28, 0x26, 0x69, 0x28, 0x2b, 0x3b, 0x20, 0x3b, 0x69, 0x39, 0x3b, 0x26, 0x2a, 0x2c, 0x3a, 0x3a, 0x26, 0x73, 0x69, 0x79, 0x31, 0x6c, 0x11, 0x43 }).c_str()
#define STR5 Decrypt({ 0x19, 0x3b, 0x26, 0x2a, 0x2c, 0x3a, 0x3a, 0x26, 0x69, 0x28, 0x25, 0x3f, 0x26, 0x69, 0x20, 0x27, 0x3f, 0x28, 0x25, 0x20, 0x2d, 0x26, 0x43 }).c_str()
#define STR6 Decrypt({ 0xf, 0x28, 0x25, 0x21, 0x26, 0x3c, 0x69, 0x26, 0x69, 0x24, 0x28, 0x27, 0x3c, 0x28, 0x25, 0x43 }).c_str()


bool IsCorrectTargetArchitecture(HANDLE hProc) {
	BOOL bTarget = FALSE;
	if (!IsWow64Process(hProc, &bTarget)) {
		printf(STR, GetLastError());
		//printf("Nao pode confirmar a arquitetura alvo: 0x%X\n", GetLastError());
		return false;
	}

	BOOL bHost = FALSE;
	IsWow64Process(GetCurrentProcess(), &bHost);

	return (bTarget == bHost);
}

int main(int argc, char* argv[]) {
	char* szDllFile = argv[1];
	char szProc[] = "*:.&g,1,"; //"csgo.exe"

	if (argc != 2) {
		printf(STR2);
		//printf("Numero de argumentos invalido\n");
		system("PAUSE");
		return 0;
	}
	PROCESSENTRY32 PE32{ 0 };
	PE32.dwSize = sizeof(PE32);

	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hSnap == INVALID_HANDLE_VALUE) {
		DWORD Err = GetLastError();
		printf(STR3, Err);
		//printf("Falhou o snap: 0x%X\n", Err);
		system("PAUSE");
		return 0;
	}

	DWORD PID = 0;
	BOOL bRet = Process32First(hSnap, &PE32);
	while (bRet) {
		if (!strcmp(Decrypt(szProc).c_str(), PE32.szExeFile)) {
			PID = PE32.th32ProcessID;
			break;
		}
		bRet = Process32Next(hSnap, &PE32);
	}
	CloseHandle(hSnap);

	HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);
	if (!hProc) {
		DWORD Err = GetLastError();
		printf(STR4, Err);
		//printf("Falha ao abrir processo: 0x%X\n", Err);
		system("PAUSE");
		return 0;
	}

	if (!IsCorrectTargetArchitecture(hProc)) {
		printf(STR5);
		//printf("Processo alvo invalido\n");
		CloseHandle(hProc);
		system("PAUSE");
		return 0;
	}
	
	if (!ManualMap(hProc, szDllFile)) {
		printf(STR6);
		//printf("Falhou o manual\n");
		CloseHandle(hProc);
		system("PAUSE");
		return 0;
	}

	if (hProc) CloseHandle(hProc);
		
	return 0;
}